<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Immutable Data in Postgres</title>

		<meta name="author" content="Gary Sieling">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

<style>

.reveal img, .reveal video, .reveal iframe {
	width: 150%;
	max-height: 150%;
  position:relative;
}

		</style>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-transition="fade">
					<h1>Immutable Data</h1>
					<h3>in Postgres</h3>
					<p>
						<small>Created by <a href="http://www.garysieling.com/blog">Gary Sieling</a> / <a href="http://twitter.com/garysieling">@garysieling</a></small>
					</p>
          
					<aside class="notes">
						* Application Developer @ Wingspan Technology in Philadelphia
            * Customer Support & DBA work
					</aside>
				</section>

      	<section data-transition="fade">
					<h2>Overview</h2>
					<p>
					<ul>
						<li>Functional programming movement encourages immutable data</li>
						<li>Regulators require audit trails</li>
						<li>End users are really bad at describing problems</li>
					</p>

					<aside class="notes">
            * The recent renewal of interest of functional programming in the software development community has spurred interest in immutable data structures, especially in databases.
            * Post postgres conference - I saw a lot of people were interested in auditing from a banking perspective
            * I'm in pharma
            * Inspiration - combining these gives you ways you can help other teams save a lot of time           
					</aside>
				</section>

				<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix7.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
            * Traditional auditing requirements are a natural starting point for discussing problems around immutable data. This talk will demonstrate how historical data stored in Postgres allows our customer service team to simulate having a debugger with a long time frame, allowing us to generate timelines of data changes, validate data corrections, and build complex analytics on system usage.
						* The real problems are working under pressure (late at night, while an important client is waiting, or in a regulated environment)
						* Need to be able to install confidence- automate as much of testing/writing queries as you can; pre-write queries and re-use
						* Why data-corrections? Happen because of defects (bad data feed, application defect, design changes over time, defects in migration scripts, data maintained in separate systems)
						* Getting queries right is key - sometimes data is not indexed in a convenient way (I'm solving a team structure problem rather than a database problem)
					</aside>
				</section>

				<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix8.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
					</aside>
				</section>

      	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix9.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
					</aside>
				</section>

				
      	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
					<ul>
						<li>"Why is this different than a week ago?" - Customer</li>
						<li>Worse in regualated industries (pharma, banking)</li>
						<li>Possible to answer, but time consuming</li>
					</ul>
					</p>

					<aside class="notes">
						* This is a common customer request for us
						* Regulated industries - harder to blow off questions
						* Banking - pricing time streams
					</aside>
				</section>

       	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix11.png" />
					</p>

					<aside class="notes">
						* Time-travelling debugger
            *  Audit history typically provides a wealth of information, if you can sift through the noise. This talk discuss a variety of these issues: handling multiple overlapping time series, how to effectively filter data to points of interest, as well as performance and testing issues.
						* Heap analytics shows every click, which is richer
		</aside>
				</section>

				
				
      	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix10.png" />
					</p>

					<aside class="notes">
						* Time-travelling debugger
					</aside>
				</section>
			
       	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix12.png" />
					</p>

					<aside class="notes">
						* Time-travelling debugger
					</aside>
				</section>


 
        <section data-transition="fade">
					<h2>Design Considerations (1 of x)</h2>
					<p>
            <img src="git-extensions-history.png" />
					</p>

					<aside class="notes">
					</aside>
        </section>

        <section data-transition="fade">
					<h2>Design Considerations (1 of x)</h2>
					<p>
            <img src="wp-audit-log.png" />
					</p>

					<aside class="notes">
					</aside>
				</section>

        
        <section data-transition="fade">
					<h2>Design Considerations (1 of x)</h2>
					<p>
            <img src="git-extensions-commands.png" />
					</p>

					<aside class="notes">
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Design Considerations (1 of x)</h2>
					<p>
             <ul>
               <li>Request context (user/guid)</li>
               <li>Usage (current vs historical)</li>
               <li>Storage (deltas vs full data)</li>               
               <li>Manner of use (readonly production access vs. planned)</li>               
             </ul>
					</p>

					<aside class="notes">
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Data Model</h2>
					<p>
					<pre><code data-trim>
create table movies (title text);

create table movies$a (title text, audit_date timestamp(3));

create trigger movies$t
  after insert on movies 
  for each row execute procedure audit();

CREATE FUNCTION audit() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE
    'INSERT INTO movies$a (text, audit_date) VALUES ($1.text, $2);'
END;
$$;
					</code></pre>
					</p>

					<aside class="notes">
              * You can build this with logic but it will be a little slow
              * Create one trigger per operation (insert / update / delete)
              * Create one trigger per table (generate SQL)
              * Do we need to force immutability with permissions?
							* where is 'new'
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Procedures witin Procedures</h2>
					<p>
					<pre><code data-trim>
   table_name = current_schema || '.' || format('%I', tables.table_name);

    table_sql := 
      format(
       'create table %s$a
        as select t.*, 
             null::varchar(1) audit_action,
             null::varchar audit_request,
             null::bigint audit_txid,
             null::varchar audit_user, 
             null::timestamp audit_date
           from %s t 
           where 0 = 1',
       table_name,
       table_name
    );
					</code></pre>
					</p>

					<aside class="notes">
						* Can turn off these triggers during migrations
						* May want be able create large load system
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Data Model</h2>
					<p>
          <pre><code data-trim>
SELECT txid_current(); 
					</code></pre>

          <pre><code data-trim>
SELECT 
  split_part(application_name, ',', 1) user,
  split_part(application_name, ',', 2) request
FROM pg_stat_activity 
WHERE procpid = pg_backend_pid() 
INTO v_context;
					</code></pre>

					</p>

					<aside class="notes">
						* TG_OP - can record operation type and pick new vs old if you combine triggers
            * application_name lets you inject context - could be current user or request guid             
					</aside>
				</section>
			
	<section data-transition="fade">
					<h2>Demo - Blame Tool (x of x)</h2>
          <pre><code data-trim>
select a.*
      (title <> lead(title) over w) title$c,
from movies$a a
where audit_action in ('I', 'U')
window w as (partition by id order by audit_date desc)
</code></pre>
					<aside class="notes">
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Demo - Blame Tool (x of x)</h2>
          <pre><code data-trim>
with history as (...)

select history.*,
  (case when (title <> lead(title) over y) 
   then audit_user else null end) title$u, 
  dense_rank() over y title$r

from history

window y as (
  partition by id order by audit_date desc, title$c desc)
) b
</code></pre>
					<aside class="notes">
					</aside>
				</section>

     <section data-transition="fade">
					<h2>Demo - Blame Tool (x of x)</h2>
          <pre><code data-trim>
with history as (...),
     ordered_history as (...)

select * 
from ordered_history 
where title$r = 1
</code></pre>
					<aside class="notes">
					</aside>
				</section>        
								
				<section data-transition="fade">
					<h2>Demo - Rollback Tool</h2>
          	<pre><code data-trim>
from_sql := 
  format(
'-- query to find what to undo
select %s, b.*
from (
  select a.*,
         %s
  from %s a
  window w as (partition by id order by audit_date desc)
) b
%s
order by audit_date desc
',
  per_column('%% <> ${column}$p as ${column}$c', table, reserved_columns),
  per_column('lead(${column}) over w ${column}$p', table, reserved_columns),
  table,
  where_clause
);
</code></pre>
					<aside class="notes">
            * Things to note: comment at the beginning
            * Previous code was impossible to read
            * Need function oriented code (array -> string)
            * Needs to work by taking working sql -> templatize
            * Need to run build script, backup schema, checkin
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Generating Ranges (1 of 3)</h2>
					<p>
					<pre><code data-trim>
select
  id, title
from
  movies_vw
where 
  license_effective @> now()
					</code></pre>

					</p>

					<aside class="notes">
						* Note use of range
            * Postgres provides a number of built-in features that support sophisticated analysis, such as time range operators and window functions. Since Postgres allows easy inspection of the database schema, these features are far more powerful when used in dynamic sql generated in stored procedures.					
            * This will be the building blocks for everything coming
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Generating Ranges (2 of 3)</h2>
					<pre><code data-trim>          
  CREATE view movie_ranges AS 
  SELECT
    tsrange(
      s.audit_date, 
      coalesce(lead(s.audit_date) 
                 over(
                   partition by s.i_id 
                   order by s.audit_date), 
               'infinity'), 
               '[)'
    ) m_effective,
    m.audit_date
    movie.name,
  FROM movie$a s
					</code></pre>
				 	<aside class="notes">
						* Note open / closed ranges
            * Note finding next row in range
            * Note 'infinity' in the beginning and end range
						* TODO: -infinity is missing
          </aside>
        </section>

				<section data-transition="fade">
					<h2>Generating Ranges (3 of 3)</h2>
					<ul>
<pre><code data-trim>                      
WITH s as (
  SELECT
    *
  FROM movie_vw s
  LEFT JOIN (
    license_vw 
  ) l ON l.name = m.licensee
),
all_joined as (
  SELECT
    -- anything not found in a left join gets turned into an infinite range
    coalesce(mis_effective, tsrange('-infinity', 'infinity', '[]')) mis_effective,
    coalesce(mir_effective, tsrange('-infinity', 'infinity', '[]')) mir_effective,
    greatest(s._audit_date_, r._audit_date_) _audit_date_,
    s.tmf_level
  FROM s
  LEFT JOIN r ON s.id = r.id
)
select *
from all_joined
where ...
					</code></pre>
					</ul>
					<aside class="notes">
						* TODO: create license
            * We're on 9.1 - don't have ranges
            * Could update these in audit data
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Generating Ranges (3 of 3)</h2>
					<ul>
<pre><code data-trim>                      
...show overlapping of ranges...
...picture...
</code></pre>
					</ul>
					<aside class="notes">
						* TODO: create license
            * We're on 9.1 - don't have ranges
            * Could update these in audit data
					</aside>
				</section>


	<section data-transition="fade">
					<h2>Demo - Blame Tool with Timestamp</h2>
					<ul>
<pre><code data-trim>  
SELECT movie_user, license_user, test
FROM movies_vw
WHERE id = ...
AND date_range <@ '12345'
</code></pre>
					</ul>
					<aside class="notes">
						* TODO this requires multiple columns in the result set
						* Next slide should be the stored procedure approach

					</aside>
				</section>

   			<section data-transition="fade">
					<h2>Demo - Compare Over Time Tool</h2>
					<ul>
					</ul>
					<aside class="notes">
						* Use Except
						* We use for tuning views
					</aside>
				</section>	

	 			<section data-transition="fade">
					<h2>Demo - See Actions</h2>
					<ul>
					</ul>
					<aside class="notes">
					</aside>
				</section>	

  			<section data-transition="fade">
					<h2>Things Postgres Gives Us</h2>
					<ul>
						<li>Ranges</li>
						<li>Named window functions</li>
						<li>Array aggregation</li>
						<li>Triggers</li>
					</ul>
					<aside class="notes">
						* Wishlist - append only data
						* Update single cell in a row
					</aside>
				</section>	

				<section data-transition="fade">
					<h2>Joins</h2>
					<ul>
						<li>Allen's Interval Algebra</li>
	          <li>Join IDs from two tables as usual</li>
						<li>Secondary condition to force time range overlap</li>
					</ul>
					<aside class="notes">
						* http://en.wikipedia.org/wiki/Allen%27s_interval_algebra#Relations
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Data Corrections</h2>
					<ul>
						Can we roll back?
					</ul>
					<aside class="notes">
						* Sometimes we need audit data for the data correction
						* We'd need the audit data to re-undo
						* We need audit data to find out what someone did
					</aside>
				</section>
				
				<section data-transition="fade">
					<h2>SQL Features (1 of ...)</h2>
					<ul>
						<li>X except Y</li>
					</ul>
					<aside class="notes">
						* Good for speed
						* Good for comparisons
					</aside>
				</section>

				<section data-transition="fade">
					<h2>SQL Features (1 of ...)</h2>
					<ul>
						<li>Indexes as materialized views</li>
					</ul>
					<aside class="notes">
						* http://en.wikipedia.org/wiki/Allen%27s_interval_algebra#Relations
					</aside>
				</section>

				<section data-transition="fade">
					<h2>SQL Features (1 of ...)</h2>
					<ul>
						<li>SELECT FROM function</li>
					</ul>
					<aside class="notes">
						* Goal is to provide an API for support team
						* 4-12 hours to answer a support ticket
					</aside>
				</section>

				<section data-transition="fade">
					<h2>SQL Features (1 of ...)</h2>
					<ul>
						<li>Named window</li>
						<li>Lead / Lag</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Performance Considerations</h2>
					<ul>
						<li>Unindexed data</li>
						<li>Indexing strategy - Datomic</li>
						<li>Full text search - Splunk</li>
					</ul>
				 	<aside class="notes">
						* Data is accessed rarely, and much larger than everything else
						* Worth waiting for results, not maintaining indexes
            * Run on a snapshot of the data
            * Our data is relatively small, but audit data is a pain to copy locally
            * You're usually most interested in recent audit data
            * But Not that recently
						* Story of waiting half an hour for query results late at night
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Alternate structures</h2>
					<p>
					<ul>
						<li>Single table</li>
						<li>Query rewriting</li>
					</ul>
					</p>
				</section>
					<section data-transition="fade">
					<h2>Minutea</h2>
					<ul>
						<li>Word replaces characters</li>
						<li>Leading / trailing spaces</li>
						<li>Nulls / spaces / empty string</li>
					</ul>
				 	<aside class="notes">
						* Valid for support
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Other Considerations</h2>
					<ul>
						<li>Global sequence number</li>
						<li>Local sequence number</li>
						<li>Vector clocks</li>
					</ul>
				 	<aside class="notes">
						* (1) shows order of creation of every object in the system
						* (2) can be used to tie specific versions of records in two tables
						* (3) can be used to resolve conflicts in partitioned systems (mobile?)
						* database config lets you see history
					</aside>					
				</section>

				<section data-transition="fade">
					<h1>THE END</h1>
					<h3>Gary Sieling / @garysieling</h3>
					<h4>www.garysieling.com</h4>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
