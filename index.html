<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Immutable Data in Postgres</title>

		<meta name="author" content="Gary Sieling">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

<style>

.reveal img, .reveal video, .reveal iframe {
	width: 150%;
	max-height: 150%;
  position:relative;
}

		</style>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-transition="fade">
					<h1>Immutable Data</h1>
					<h3>in Postgres</h3>
					<p>
						<small>Created by <a href="http://www.garysieling.com/blog">Gary Sieling</a> / <a href="http://twitter.com/garysieling">@garysieling</a></small>
					</p>
          
					<aside class="notes">
						* Application Developer @ Wingspan Technology in Philadelphia
            * Customer Support & DBA work
					</aside>
				</section>

				<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix7.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
            * Traditional auditing requirements are a natural starting point for discussing problems around immutable data. This talk will demonstrate how historical data stored in Postgres allows our customer service team to simulate having a debugger with a long time frame, allowing us to generate timelines of data changes, validate data corrections, and build complex analytics on system usage.
						* The real problems are working under pressure (late at night, while an important client is waiting, or in a regulated environment)
						* Need to be able to install confidence- automate as much of testing/writing queries as you can; pre-write queries and re-use
						* Why data-corrections? Happen because of defects (bad data feed, application defect, design changes over time, defects in migration scripts, data maintained in separate systems)
						* Getting queries right is key - sometimes data is not indexed in a convenient way (I'm solving a team structure problem rather than a database problem)
					</aside>
				</section>

				<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix8.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
					</aside>
				</section>

      	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix9.png" />
					</p>

					<aside class="notes">
						* Imagine you're an L1 engineer for Netflix
					</aside>
				</section>



      	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
					<ul>
						<li>"Why is this different than a week ago?" - Customer</li>
						<li>Worse in regulated industries (e.g. pharma)</li>
						<li>Very time consuming</li>
					</ul>
					</p>

					<aside class="notes">
						* This is a common customer request for us
						* Regulated industries - harder to blow off questions
						* Banking - pricing time streams
					</aside>
				</section>

       	<section data-transition="fade">
					<h2>The Problem</h2>
					<p>
						<img src="netflix11.png" />
					</p>

					<aside class="notes">
						* Time-travelling debugger
            *  Audit history typically provides a wealth of information, if you can sift through the noise. This talk discuss a variety of these issues: handling multiple overlapping time series, how to effectively filter data to points of interest, as well as performance and testing issues.
		</aside>
				</section>


      	<section data-transition="fade">
					<h2>Overview (1 of 2)</h2>
					<p>
					<ul>
						<li>Functional programming encourages immutable data</li>
						<li>Regulators require audit trails</li>
						<li>End users are really bad at describing problems</li>
					</p>

					<aside class="notes">
            * The recent renewal of interest of functional programming in the software development community has spurred interest in immutable data structures, especially in databases.
            * Post postgres conference - I saw a lot of people were interested in auditing from a banking perspective
            * I'm in pharma
            * Inspiration - combining these gives you ways you can help other teams save a lot of time           
					</aside>
				</section>



      	<section data-transition="fade">
					<h2>Overview (2 of 2)</h2>
					<p>
					<ul>
						<li>Database Design Considerations</li>
						<li>Example Functionality</li>
						<li>Lessons Learned</li>
					</p>

					<aside class="notes">
            * The recent renewal of interest of functional programming in the software development community has spurred interest in immutable data structures, especially in databases.
            * Post postgres conference - I saw a lot of people were interested in auditing from a banking perspective
            * I'm in pharma
            * Inspiration - combining these gives you ways you can help other teams save a lot of time           
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Design Considerations (1 of 4)</h2>
					<p>
            <img src="git-extensions-history.png" />
					</p>

					<aside class="notes">
					</aside>
        </section>

        <section data-transition="fade">
					<h2>Design Considerations (2 of 4)</h2>
					<p>
            <img src="git-extensions-commands.png" />
					</p>

					<aside class="notes">
					</aside>
				</section>


        <section data-transition="fade">
					<h2>Design Considerations (3 of 4)</h2>
					<p>
            <img src="wp-audit-log.png" />
					</p>

					<aside class="notes">
					</aside>
				</section>
        

        <section data-transition="fade">
					<h2>Design Considerations (4 of 4)</h2>
					<p>
             <ul>
               <li>Request context (user/guid)</li>
               <li>Usage (current vs historical)</li>
               <li>Storage (deltas vs full data)</li>               
               <li>Manner of use (readonly production access vs. planned)</li>               
             </ul>
					</p>

					<aside class="notes">
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Data Model</h2>
					<p>
					<pre><code data-trim>
create table movies (title text);

create table movies$a (title text, audit_date timestamp(3));

create trigger movies$t
  after insert on movies 
  for each row execute procedure audit();

CREATE FUNCTION audit() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE
    'INSERT INTO movies$a (text, audit_date) VALUES ($1.text, $2);'
END;
$$;
					</code></pre>
					</p>

					<aside class="notes">
              * You can build this with logic but it will be a little slow
              * Create one trigger per operation (insert / update / delete)
              * Create one trigger per table (generate SQL)
              * Do we need to force immutability with permissions?
							* where is 'new'
					</aside>
				</section>

				<section data-transition="fade">
					<h2>SQL Templates</h2>
					<p>
					<pre><code data-trim>
table_name = current_schema || '.' || format('%I', tables.table_name);

table_sql := 
  format(
    'create table %s$a
     as select t.*, 
       null::varchar(1) audit_action,
       null::varchar audit_request,
       null::bigint audit_txid,
       null::varchar audit_user, 
       null::timestamp audit_date
     from %s t 
     where 0 = 1',
     table_name,
     table_name
);
					</code></pre>
					</p>

					<aside class="notes">
						* Can turn off these triggers during migrations
						* May want be able create large load system
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Data Sources</h2>
					<p>
          <pre><code data-trim>
SELECT txid_current(); 
					</code></pre>

          <pre><code data-trim>
SELECT 
  split_part(application_name, ',', 1) user,
  split_part(application_name, ',', 2) request
FROM pg_stat_activity 
WHERE procpid = pg_backend_pid() 
INTO v_context;
					</code></pre>

					</p>

					<aside class="notes">
						* TG_OP - can record operation type and pick new vs old if you combine triggers
            * application_name lets you inject context - could be current user or request guid             
					</aside>
				</section>
			
       	<section data-transition="fade">
					<h2>Example Functionality</h2>	
        	<p>
             <ul>
               <li>Blame</li>
							 <li>Undo</li>
							 <li>Time-travelling debugger</li>
             </ul>
					</p>					
					<aside class="notes">

					</aside>					 
			  </section>

	<section data-transition="fade">
					<h2>Demo - Blame Tool (1 of 3)</h2>
          <pre><code data-trim>
select a.*
      (title <> lead(title) over w) title$c,
from movies$a a
where audit_action in ('I', 'U')
window w as (partition by id order by audit_date desc)
</code></pre>
					<aside class="notes">
					</aside>
				</section>

        <section data-transition="fade">
					<h2>Demo - Blame Tool (2 of 3)</h2>
          <pre><code data-trim>
with history as (...)

select history.*,
  (case when (title <> lead(title) over y) 
   then audit_user else null end) title$u, 
  dense_rank() over y title$r

from history

window y as (
  partition by id order by audit_date desc, title$c desc)
) b
</code></pre>
					<aside class="notes">
					</aside>
				</section>

     <section data-transition="fade">
					<h2>Demo - Blame Tool (3 of 3)</h2>
          <pre><code data-trim>
with history as (...),
     ordered_history as (...)

select * 
from ordered_history 
where title$r = 1
</code></pre>
					<aside class="notes">
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Undo (1 of 4)</h2>	
        	<p>
             <ul>
               <li>Infrequent data changes (fix output of software)</li>
							 <li>Target change by user/request/time</li>
							 <li>Undo changed columns</li>
							 <li>Output SQL</li>
							 <li>Report on the results</li>
             </ul>
					</p>					
					<aside class="notes">

					</aside>					 
			  </section>

				<section data-transition="fade">
					<h2>Undo (2 of 4)</h2>
          	<pre><code data-trim>
-- undo query
with prior as (
  select rank() over w,
         audit_data.*         
  from tenant1.movies$a audit_data
  where audit_data.audit_txid = 517093 
  window w as (partition by id order by audit_date desc)
  order by 1 
  offset 1 
  limit 1
)
update ...
</code></pre>
					<aside class="notes">
           4
					</aside>
				</section>
				

				<section data-transition="fade">
					<h2>Undo (3 of 4)</h2>
          	<pre><code data-trim>
-- undo query
with prior as (...)
update movies$a audit_data
set 
  title = 
    (case when 
      (audit_data.title <> prior.title) or
      (audit_data.title is null and prior.title is not null) or 
      (audit_data.title is not null and audit_data.title is null)
    then prior.title 
    else audit_data.title 
    end),
  ...
from prior
where audit_data.audit_txid = 517093
</code></pre>
					<aside class="notes">
           
					</aside>
				</section>
				


				<section data-transition="fade">
					<h2>Undo (4 of 4)</h2>
          	<pre><code data-trim>
 format('--insert sql here--',
      per_column('
  ${column} = 
    (case when 
      (audit_data.${column} <> prior.${column}) or
      (audit_data.${column} is null and prior.${column} is not null) or 
      (audit_data.${column} is not null and audit_data.${column} is null)
    then prior.${column} 
    else audit_data.${column} 
    end)', ', ', 
    current_schema::varchar, tables.table_name, reserved_columns))
</code></pre>
					<aside class="notes">
            * Things to note: comment at the beginning
            * Previous code was impossible to read
            * Need function oriented code (array -> string)
            * Needs to work by taking working sql -> templatize
            * Need to run build script, backup schema, checkin
					</aside>
				</section>
				
        <section data-transition="fade">
					<h2>Principals for Data Corrections</h2>
					<ul>
						<li>Provide production data to developers</li>
						<li>Scrub data for personal information</li>
						<li>Especially remove email addresses</li>
						<li>Produce a before/after report</li>
						<li>Repeatable code</li>
					</ul>
					<aside class="notes">
						* Sometimes we need audit data for the data correction
						* We'd need the audit data to re-undo
						* We need audit data to find out what someone did
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Time Travelling Debugger (1 of 6)</h2>
					<p>
					<pre><code data-trim>
select
  id, title
from
  movies_vw
where 
  license_effective @> now()
					</code></pre>

					</p>

					<aside class="notes">
						* Note use of range
            * Postgres provides a number of built-in features that support sophisticated analysis, such as time range operators and window functions. Since Postgres allows easy inspection of the database schema, these features are far more powerful when used in dynamic sql generated in stored procedures.					
            * This will be the building blocks for everything coming
					</aside>
				</section>


        <section data-transition="fade">
					<h2>Time Travelling Debugger (2 of 6)</h2>
					<pre><code data-trim>          
CREATE view movie_history AS 
SELECT
  tsrange(
    s.audit_date, 
    coalesce(lead(s.audit_date) over w, 'infinity'), 
    '[)'
  ) m_effective,
  ...
FROM movie$a s
JOIN license$a l on s.license_id = s.id
window w as (partition by id order by audit_date desc)
					</code></pre>
				 	<aside class="notes">
						* Note open / closed ranges
            * Note finding next row in range
            * Note 'infinity' in the beginning and end range
						* TODO: -infinity is missing
          </aside>
        </section>

				<section data-transition="fade">
					<h2>Time Travelling Debugger (3 of 6)</h2>
<pre><code data-trim>                      
CREATE VIEW movie_ranges
SELECT
  coalesce(
    license_effective, 
    tsrange('-infinity', 'infinity', '[]')) license_effective,
  ...
FROM movie_history 
					</code></pre>
					<aside class="notes">
						* TODO: create license
            * We're on 9.1 - don't have ranges
            * Could update these in audit data
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Time Travelling Debugger (4 of 6)</h2>
<pre><code data-trim>                      
SELECT *
FROM movie_ranges
WHERE movie_effective OVERLAPS license_effective
					</code></pre>
					<aside class="notes">
            * We're on 9.1 - don't have ranges
            * Could update these in audit data
					</aside>
				</section>

	<section data-transition="fade">
					<h2>Time Travelling Debugger (5 of 6)</h2>
<pre><code data-trim>  
SELECT movie_user, license_user, test
FROM movies_vw
WHERE id = ...
AND movie_effective <@ NOW()
AND license_effective <@ NOW()
</code></pre>
					<aside class="notes">

					</aside>
				</section>
				
	<section data-transition="fade">
					<h2>Time Travelling Debugger (6 of 6)</h2>
<pre><code data-trim>  
.. TODO ..
</code></pre>
					<aside class="notes">

					</aside>
				</section>

				<section data-transition="fade">
					<h2>Joins</h2>
					<ul>
						<li>Allen's Interval Algebra</li>
	          <li>Join IDs from two tables as usual</li>
						<li>Secondary condition to force time range overlap</li>
					</ul>
					<aside class="notes">
						* http://en.wikipedia.org/wiki/Allen%27s_interval_algebra#Relations
					</aside>
				</section>

      	<section data-transition="fade">
					<h2>Lessons Learned</h2>
					<ul>
						<li>Indexing Audit History</li>
						<li>Working with unindexed data</li>
						<li>Testing SQL</li>
					</ul>
				 	<aside class="notes">
					</aside>
				</section>


      	<section data-transition="fade">
					<h2>Indexing</h2>
					<ul>
						<li>Unindexed data</li>
						<li>Indexing strategy - Datomic</li>
						<li>Full text search - Splunk</li>
					</ul>
				 	<aside class="notes">
					</aside>
				</section>

				
				<section data-transition="fade">
					<h2>Unindexed Data</h2>
					<ul>
						<li>Single pass algorithms</li>
						<li>Filter queries as soon as possible</li>
						<li>Use 'except' to compare queries</li>
					</ul>
				 	<aside class="notes">
					</aside>
				</section>

				<section data-transition="fade">
					<h2>Testing Considerations</h2>
					<ul>
						<li>Use 'except' to compare queries</li>
						<li>Database replicas</li>
						<li>SQL tools hide whitespace</li>
					</ul>
				 	<aside class="notes">
						* Also the weird characters MS Word makes
						* Also nulls vs other stuff
					</aside>
				</section>
			
				<section data-transition="fade">
					<h1>THE END</h1>
					<h3>Gary Sieling / @garysieling</h3>
					<h4>www.garysieling.com</h4>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
